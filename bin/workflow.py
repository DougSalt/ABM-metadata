#!/usr/bin/env python3

__copyright__ = "Copyright 2016"
__license__ = "This program is a free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the Licence, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see <http://www.gnu.org/licenses/>."
__version__ = "1.0.0"
__authors__ = "Doug Salt"
__credits__ = ""

import graphviz, os, sys, re

sys.path.append("lib")
import ssrepi

# This program is going to gather all the workflow stuff into a graphviz diagram.

activeNodes = {}

class InvalidNode(Exception):
    pass

nodes = {
    'Applications': 'ID_APPLICATION',
    'Pipelines': 'ID_PIPELINE',
    'StatisticalMethods': 'ID_STATISTICAL_METHOD',
    'ContainerTypes': 'ID_CONTAINER_TYPE',
    'StatisticalVariables': 'ID_STATISTICAL_VARIABLE',
    'Variables': 'ID_VARIABLE',
    'VisualisationMethods': 'ID_VISUALISATION_METHOD',
    'Parameters': 'ID_PARAMETER',
    'Arguments': 'ID_ARGUMENT'
    }


class InvalidEdge(Exception):
    pass
	
edges = { 
    'implements': { 
        'join': {'source': 'Implements(APPLICATION)',
                 'target': 'Implements(STATISTICAL_METHOD)'
                 },
        'source': 'Applications(ID_APPLICATION)', 
        'target': 'StatisticalMethods(ID_STATISTICAL_METHOD)' 
        },
    'calls pipeline': {
        'id': 'Pipelines(ID_PIPELINE)',
        'source': 'Pipelines(CALLS_PIPELINE)',
        'target': 'Applications(ID_PIPELINE)'
        },
    'calls': {
        'id': 'Pipelines(ID_PIPELINE)',
        'source': 'Pipelines(CALLS_APPLICATION)',
        'target': 'Applications(ID_APPLICATION)'
        },
    'calls application': {
        'id': 'Applications(ID_APPLICATION)',
        'source': 'Applications(CALLS_APPLICATION)',
        'target': 'Applications(ID_APPLICATION)'
        },
    'calls pipeline': {
        'id': 'Applications(ID_APPLICATION)',
        'source': 'Applications(CALLS_PIPELINE)',
        'target': 'Pipelines(ID_PIPELINE)'
        },
    'next': {
        'id': 'Pipelines(ID_PIPELINE)',
        'source': 'Pipelines(NEXT)',
        'target': 'Pipelines(ID_PIPELINE)'
        },
    'uses': {
        'join': {
            'source': 'Uses(APPLICATION)',
            'target': 'Uses(CONTAINER_TYPE)'
            },
        'source': 'Applications(ID_APPLICATION)',
        'target': 'ContainerTypes(ID_CONTAINER_TYPE)',
        'direction': 'reverse'
        },
    'product': {
        'join': {
            'source': 'Products(APPLICATION)',
            'target': 'Products(CONTAINER_TYPE)'},
        'source': 'Applications(ID_APPLICATION)',
        'target': 'ContainerTypes(ID_CONTAINER_TYPE)'
        },
    'contains variable': {
        'join':{
            'source': 'Contents(CONTAINER_TYPE)',
            'target': 'Contents(VARIABLE)'
            },
        'source': 'ContainerTypes(ID_CONTAINER_TYPE)',
        'target': 'Variables(ID_VARIABLES)'
        },
    'generated by': { 
        'id': 'StatisticalVariables(ID_STATISTICAL_VARIABLE)',
        'source': 'StatisticalVariables(GENERATED_BY)', 
        'target': 'StatisticalMethods(ID_STATISTICAL_METHOD)'
        },	
    'statistical parameter': {
        'id': 'Parameters(ID_PARAMETER)',
        'source': 'Parameters(STATISTICAL_METHOD)',
        'target': 'StatisticalMethods(ID_STATISTICAL_METHOD)'
        },
    'visualisation parameter': {
        'id': 'Parameters(ID_PARAMETER)',
        'source': 'Parameters(VISUALISATION_METHOD)',
        'target': 'VisualisationMethods(ID_VISUALISATION_METHOD)'
        },
    'employs statistical method': {
        'join':{
            'source': 'Employs(STATISTICAL_VARIABLE)',
            'target': 'Employs(STATISTICAL_METHOD)'
            },
        'source': 'StatisticalVariables(ID_STATISTICAL_VARIABLE)',
        'target': 'StatisticalMethods(ID_STATISTICAL_METHOD)'
        },
    'employs visualisation method': {
        'join':{
            'source': 'Employs(STATISTICAL_VARIABLE)',
            'target': 'Employs(VISUALISATION_METHOD)'
            },
        'source': 'StatisticalVariables(ID_STATISTICAL_VARIABLE)',
        'target': 'VisualisationMethods(ID_VISUALISATION_METHOD)'
        },
    'argument for': {
        'id': 'Arguments(ID_ARGUMENT)',
        'source': 'Arguments(APPLICATION)', 
        'target': 'Applications(ID_APPLICATIONS)'
        },
    'is a': {
        'id': 'Arguments(ID_ARGUMENT)',
        'source': 'Arguments(VARIABLE)', 
        'target': 'Variables(ID_VARIABLE)'
        }
    }
       

# This next dictionary affects how the diagram is labelled.  If the
# entry appears here then it will be used as a label.  Consequently to
# adjust, or add then change this dictionary.  Obviously bearing in
# mind that any entry in this array has to be for a valid table and an
# attribute for that table.

# Also note that some of these tables constitute edges rather than
# nodes, so it might be edges that are labelled with the information
# below.

labels = { 
    'Applications': [
        'ID_APPLICATION',
        'PURPOSE',
        'VERSION',
        'LICENCE',
        'LANGUAGE',
        ],
    'Implements': [
        'FUNCTION',
        'LIBRARY'
        ],
    'Pipelines': [
        'ID_PIPELINE',
        'DESCRIPTION'],
    'Uses': [
        'OPTIONALITY'
        ],
    'Products': [
        'OPTIONALITY'
        ],
    'StatisticalMethods': [
        'ID_STATISTICAL_METHOD'
        ],
    'ContainerTypes': [
        'ID_CONTAINER_TYPE'
        ],
    'StatisticalVariables': [
        'ID_STATISTICAL_VARIABLE',
        'DATA_TYPE'
        ],
    'Contents': [
        'OPTIONALITY'
        ],
    'Variables': [
        'ID_VARIABLE',
        'DATA_TYPE'
        ],
    'VisualisationMethods': [
        'ID_VISUALISATION_METHOD'
        ],
    'Parameters': [
        'ID_PARAMETER',
        'DATA_TYPE'
        ],
    'Arguments': [
        'ID_ARGUMENT',
        'TYPE',
        'DESCRIPTION',
        'RANGE',
        'ORDER_VALUE'
        ]
    }


# working_dir = os.getcwd()

# db_specs = ssrepi.connect_db(working_dir)

# graph = ssrepi.graph()
# activeNodes = ssrepi.draw_nodes(db_specs[0], graph, nodes, labels)
# graph = ssrepi.draw_edges(db_specs[0], graph, edges, labels, activeNodes)

# print graph 

# ssrepi.disconnect_db(db_specs[0])

working_dir = os.getcwd()

db_specs = ssrepi.connect_db(working_dir)

originalNodes = ssrepi.get_nodes(db_specs[0], nodes, labels)
activeEdges = ssrepi.get_edges(db_specs[0], edges, originalNodes)
activeNodes = ssrepi.remove_orphans(originalNodes, activeEdges)
ssrepi.draw_graph(activeNodes,activeEdges,output="workflow.dot")

ssrepi.disconnect_db(db_specs[0])
